
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="//code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
<link rel="stylesheet" href="/resources/demos/style.css">
<script src="https://code.jquery.com/jquery-1.12.4.js"></script>
<script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>

<script src="video-browser.js"></script>


<head>
<style>
body {
  font-family: 'Tangerine', serif;
}

#video_list{
  text-align:center;
}

#img_list{
  text-align:center;
}

#div_add_stream{
  border-style:solid;
  border-width:1px;
  width:250px;
}

#div_add_stream p{
  text-align:center;
}


.debug_div {
}

.debug_div img{
  width:250px;
}

.meta{]
  text-align:center;
  font-size: 12px;
}

.videos{
  position:relative;
  width:400px;
  height:280px;
  float:left;
  margin-left:10px;
  border-style:solid;
  border-width:1px;
}

video{
  position:absolute;
  top: 0;
  left: 0;
  width:400px;
  z-index: -30;
}

canvas {
  top: 0;
  left: 0;
  width:400px;
  height:240px;
  z-index: 30;
}
</style>

<script language="javascript">


buffer      = {}
bufferSize  = 5 // seconds

function draw_boxing(packet, video_name){
  // Configure the canvas
  // set the resolution
  $("#canva_"+video_name).attr("width", packet.meta.shape[1] + "px")
  $("#canva_"+video_name).attr("height", packet.meta.shape[0] + "px")
  // set size and location according to the video
  $("#canva_"+video_name).css("width",$("#video_"+video_name).width())
  $("#canva_"+video_name).css("height",$("#video_"+video_name).height())
  $("#canva_"+video_name).css("left",-$("#video_"+video_name).width())
  $("#canva_"+video_name).css("top",5)

  // load caneva context
  var ctx=$("#canva_"+video_name)[0].getContext("2d");
  ctx.clearRect(0, 0, $("#video_"+video_name).width(), $("#video_"+video_name).height());

  // Draw the boxings
  for (var detec in packet.meta.detection){
    var label  = packet.meta.detection[detec][0]
    var accur  = packet.meta.detection[detec][1]
    var boxing = packet.meta.detection[detec][2]
    scaleX = ($("#video_"+video_name).width() / packet.meta.shape[1] )
    scaleY = ($("#video_"+video_name).height() / packet.meta.shape[0] )

    x = boxing[0] - (boxing[2] / 2)
    y = boxing[1] - (boxing[3] / 2)
    w = boxing[2]
    h = boxing[3]


    ctx.beginPath();
    ctx.strokeStyle="red";
    ctx.rect(x, y, w, h);
    ctx.font = "18px Arial";
    ctx.fillStyle = "red";
    ctx.fillText(label,x+10,y+15);
    ctx.stroke();
  }
}

function process_boxing_packet(packet){
  //console.log(JSON.stringify(packet))
  framerate       = packet.meta.meta.frame_rate_processing
  var video_name  = packet.meta.from.replace(/\./g,"_").replace(/-/g,"_").replace(/ /g,"_")
  var video       = $("#video_"+video_name).get(0)
  var video_url   = packet.meta.path

  if (video_url.indexOf("http") == -1 && video_url.indexOf("rtsp") == -1)
    video_url = "http://tidzam.media.mit.edu"+video_url

  // ================= VIDEO OBJECT CREATION WITH ITS DRAWING LOOP
  // If the video is not loaded, we create the object and start the video
  if(!video){
    var img = $('<div class="videos" id="p_'+video_name+'"><video controls id="video_'+video_name+'" src="'+video_url+'" type="video/mp4"></video>'+
                '<canvas id="canva_'+video_name+'"></canvas><p class="meta" id="meta_'+video_name+'">No video information.</p></div>');
    img.appendTo('#video_list');
    buffer[$("#video_"+video_name).get(0).id] = []

    function draw(video_name, count) {

      try{
      // Get the object video
      video_obj             = $("#video_"+video_name).get(0)
      if (!video_obj.paused) count = 0
      else count ++;
      // Get the frame time of the next boxing in the queue
      packet_currentTime    = Math.floor(buffer[video_obj.id][0].meta.frame_count / framerate)

      // Print Meta data
      if (buffer[video_obj.id][0].meta.meta.startTime)
        $('#meta_'+video_name).html( buffer[video_obj.id][0].meta.from + ' <br> ' +
            (new Date(buffer[video_obj.id][0].meta.meta.startTime + (video_obj.currentTime)*1000 ) ).toLocaleString() + ' - ' +
            buffer[video_obj.id][0].meta.meta.frame_rate_processing + " FPS " +buffer[video_obj.id][0].meta.meta.width+'x'+buffer[video_obj.id][0].meta.meta.height )

      // If the next boxing in queue is corresponding to current video frame, we draw it
      if (Math.abs(video_obj.currentTime - packet_currentTime) < 0.1 ){
        //console.log(video_obj.currentTime + " = " + packet_currentTime)
        draw_boxing(buffer[video_obj.id][0], video_name)
        buffer[video_obj.id].shift()
        }

      // Clean the buffer just in case there is old boxings which has not been processed
      framerate  = eval(packet.meta.meta.frame_rate_processing)
      for(var i=0; i < buffer[video_obj.id].length; i++)
        if ( Math.floor(buffer[video_obj.id][i].meta.frame_count / framerate) < video_obj.currentTime)
          buffer[video_obj.id].splice(i,1)
      }
      catch(err){
        ;// TODO console.log("Drawing box no ready")
      }
      // Try to draw the boxing each ms
      if (video_obj.ended || count > 10 * framerate){
        console.log("delete " + video_obj.ended + " " + count)
        $("#p_"+video_name).remove()
      }
      // Call the draw function two time between processing framerate
      else setTimeout(function(){draw(video_name, count)}, (1 / (2*framerate) ) * 1000);
    }
    draw( video_name , 0 );
    return
  }

  // ================= ADD CURRENT PACKET IN POOL AND REORDER IT (in case that packet doesn t arrive in right order)
  buffer[video.id].push(packet)
  buffer[video.id].sort(function(packet1, packet2) {
      return packet1.meta.frame_count - packet2.meta.frame_count;
      });


  // ================= MANAGE THE BOXING PACKET BUFFERING
  playback_currentTime  = $("#video_"+video_name).get(0).currentTime
  packet_currentTime    = Math.floor(buffer[video.id][buffer[video.id].length-1].meta.frame_count / framerate)
  //console.log("Receive " + packet_currentTime + " at " + playback_currentTime)
  //console.log(buffer[$("#video_"+video_name).get(0) .id].length)

  if (packet_currentTime > bufferSize + playback_currentTime){
      video.currentTime = Math.floor(buffer[video.id][0].meta.frame_count / framerate)
      video.play()
      console.log("Load movie " + video_name + " at " + packet_currentTime)
  }
  else if (!video.paused && Math.floor(packet.meta.frame_count / framerate)  <=  playback_currentTime){
    video.pause()
    console.log("Pause movie " + video_name + " ("+Math.floor(packet.meta.frame_count / framerate)  +"<="+  playback_currentTime+") ")
  }
  else if (video.paused){
    console.log("Play movie " + video_name + " ("+Math.floor(packet.meta.frame_count / framerate)  +"<="+  playback_currentTime+") ")
    video.play()
  }
}

/**************************************************************
GENERAL INTERFACE
* Connect to ws://XXXX/
* Read the boxing packet and draw them on the video flow
**************************************************************/
var socket = new WebSocket("ws://" + window.location.host + ":8765");
socket.binaryType = 'blob' // 'blob' //or ArrayBuffer
socket.onmessage = function(e){
  //alert(e.data);
  var reader = new FileReader();
  reader.onload  = function() {
    packet = bson_decode(this.result)
    //debug_loadImage(packet)
    process_boxing_packet(packet);

    }
  reader.readAsArrayBuffer(e.data);
  }


  /**************************************************************
  DEBUG INTERFACE
  * Connect to ws://XXXX/debug/
  * Read the boxed frame from the server and show them
  **************************************************************/

  var debug_loadImage = function(packet) {
    var urlCreator  = window.URL || window.webkitURL;
    var imageUrl    = urlCreator.createObjectURL(packet.img);
    var video_name  = "video_"+packet.meta.from.replace(/\./g,"_").replace(/-/g,"_").replace(/ /g,"_")


    if(!$("#img_"+video_name).get(0)){
      var img = $('<div class="debug_div"><img id="img_'+video_name+'"><br><span>'+packet.meta.from+' ('+packet.meta.shape+')</span><div>');
      img.appendTo('#img_list');
    }
    $("#img_"+video_name).attr('src', imageUrl);
  }


  if (false){
    var socket_debug = new WebSocket("ws://" + window.location.host + ":8765/debug/");
    socket_debug.binaryType = 'blob' // 'blob' //or ArrayBuffer
    socket_debug.onmessage = function(e){
      //alert(e.data);
      var reader = new FileReader();
      reader.onload  = function() {
        packet = bson_decode(this.result)
        debug_loadImage(packet)

        }
      reader.readAsArrayBuffer(e.data);
      }
    }

    /**************************************************************
    ADMIN INTERFACE
    * Connect to ws://XXXX/admin/
    * Read the boxed frame from the server and show them
    **************************************************************/
    //https://tidmarsh.link:7443/api/2.0/recording/5aae10fb6bb61c79a4ff1caf/download?apiKey=tOPvRsuHCAU74ymg
    var socket_admin = new WebSocket("ws://" + window.location.host + ":4652/unify/");
    socket_admin.onmessage = function(e){
      console.log(e)
      }

    $( document ).ready(function() {
      dialog = $( "#div_add_stream" ).dialog({
        autoOpen: false,
        height: 200,
        width: 350,
        modal: true,
        buttons: {
          "Add stream": function(){
            socket_admin.send(JSON.stringify({
              name:$("#name_url").val(),
              url:$("#stream_url").val()
            }))

            console.log("Stream request :" + $("#name_url").val() + " - " + $("#stream_url").val() )
          },
          Cancel: function() {
            dialog.dialog( "close" );
          }
        },
        close: function() {
          form[ 0 ].reset();
          allFields.removeClass( "ui-state-error" );
        }
      });

      $( "#add_stream" ).button().on( "click", function() {
        dialog.dialog( "open" );
      });
    });
</script>
</head>
<body>
<div id="div_add_stream" title="Add new web stream">
  Name: <input type="text" id="name_url"><br>
  URL: <input type="text" id="stream_url"><br>
</div>
<input id="add_stream" type="button" value="Create">



<div id="video_list"></div>
<div id="img_list"></div>

</body>
</html>
